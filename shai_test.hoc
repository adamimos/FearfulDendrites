//Author: Etay Hay, 2011
//  Models of Neocortical Layer 5b Pyramidal Cells Capturing a Wide Range of
//  Dendritic and Perisomatic Active Properties
//  (Hay et al., PLoS Computational Biology, 2011) 
//
// A simulation of L5 Pyramidal Cell BAC firing.

//============== ADAM SHAI MODIFIED THIS SIMULATION IN OCTOBER 2012 
//============== FOR LUCY PALMER'S AND MATTHEW LARKUM'S L2/3 NMDA PROJECT 


//====================== General files and tools =====================
load_file("nrngui.hoc")

//====================== cvode =======================================
objref cvode

cvode = new CVode()
cvode.active(1)

//=================== creating cell object ===========================
load_file("import3d.hoc")
objref L5PC

strdef morphology_file
morphology_file = "./Lucy23Cell1.asc"

load_file("./L5PCbiophys3.hoc")
load_file("./L5PCtemplate.hoc")
L5PC = new L5PCtemplate(morphology_file)


//================ ADAM PROCEDURES AND FUNCTIONS =======================
xopen("DefineSections.hoc")

xopen("ChangeBiophys.hoc")

xopen("AccessoryFunctions.hoc")

xopen("distSynsUniform.hoc")
xopen("distSynsCluster2.hoc")

/*
Compute_Sag()
Compute_Zin()
Compute_SagDend()
*/

objref synList1, synList2, synList3, synList4
synList1 = new List()
synList2 = new List()
synList3 = new List()
synList4 = new List()
//synList = distSynsUniform(100, basalList,1,1)
nClustTuft = 30
nClustBasal = 4
nPerClust = 3
//synList1 = distSynsCluster2(nClustTuft,tuftList,1,1,nPerClust,15)	 // clustered tuft input
synList1 = distSynsUniform(nClustTuft*nPerClust,tuftList,1,1)
synList2 = distSynsCluster2(nClustBasal,basalList,1,1,nPerClust,15) // cluster basal input
synList3 = distSynsUniform(100,allSections,1,1) // background input

// numClust = $1 //number of clusters
	// section list for synapses to be distributed over= $2
	// gmax = $3, this is the max conductance of the nmda current
	// ntar = $4, this defines the conductance of the ampa current
	//            with ampa current = gmax/ntar
	// synsPerClust =$5 //number of synapses per cluster
	// lClust = $6 //length of cluster

for i=0,synList1.count()-1{
    shapeG.point_mark(synList1.object(i),2,"O",3)
}


/*for i=0,synList2.count()-1{
    shapeG.point_mark(synList2.object(i),2,"O",4)
}
*/



for i=0,synList3.count()-1{
    shapeG.point_mark(synList3.object(i),4,"O",3)
}
//=================== SIMULATION ================================


print "\n\n\nSTART THE TUNING OF BACKGROUND SYNAPSES\n"
print "Stage 1: Find Resting State"


// Set all conductances to zero
for i=0,synList1.count()-1{ synList1.object(i).gmax = 0.0 }
for i=0,synList2.count()-1{ synList2.object(i).gmax = 0.0 }
for i=0,synList3.count()-1{ synList3.object(i).gmax = 0.0 }

// Find resting potential
access L5PC.soma
objref vrec
vrec = new Vector()
vrec.record(&L5PC.soma.v(0.5))
finitialize(-89.7)
forall{ v = -90 }
tstop = 20000
run()
vrest = vrec.x[vrec.size() - 1]
print "REST AFTER LONG CVODE RUN IS ", vrest, " AT TIME ", t
objref svstate
svstate  = new SaveState()
svstate.save()
cvode.active(0)
finitialize(-89.7)
svstate.restore()
tstop = t+20
dt = 0.025
//dt = 0.1
while(t<tstop){fadvance()}
vrest = vrec.x[vrec.size() - 1]
print "REST AFTER NONCVODE RUN IS ", vrest, " AT TIME ", t

simStopTime = t
svstate.save()

objref trec, g1
g1 = new Graph()
g1.view(21272, -80, 800, 120, 200, 200, 300.48, 200.32)  // draws it on the screen
g1.addvar("v(.5)")
access L5PC.soma
distance(0)



objref vd
objref vg

vd = new Vector()
vg = new Vector()




objref vBrec,r3
vBrec = new Vector()
print "Begin iterating through background synapses"
for i=0,synList3.count()-1{ 
	where = synList3.object(i).get_loc()
	distdist = distance(where)
	pop_section()
	synList3.object(i).gmax = 0.2683+0.0625*exp(distdist/158.0158)
	synList3.object(i).gmax = synList3.object(i).gmax*1.1
	r3 = new Random(i*328)
	synList3.object(i).del = simStopTime+r3.uniform(-132,132)
	synList3.object(i).ntar = 1
	synList3.object(i).Tspike = r3.uniform(20,100) //50 Hz
	synList3.object(i).Nspike = 50
	

	print "Added a background synapse at distance ", distdist, " with timing of ", synList3.object(i).del-simStopTime
}
		vBrec = new Vector()
		trec = new Vector()
		svstate.restore(1)
		tstop = t+800
		dt = 0.05
		//dt = 0.1
		while(t<tstop){
			fadvance()
			vBrec.append(L5PC.soma.v)
			trec.append(t)
			}










