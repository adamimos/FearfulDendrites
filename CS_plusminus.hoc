//Author: Etay Hay, 2011
//  Models of Neocortical Layer 5b Pyramidal Cells Capturing a Wide Range of
//  Dendritic and Perisomatic Active Properties
//  (Hay et al., PLoS Computational Biology, 2011) 
//
// A simulation of L5 Pyramidal Cell BAC firing.

//============== ADAM SHAI MODIFIED THIS SIMULATION IN OCTOBER 2012 
//============== FOR LUCY PALMER'S AND MATTHEW LARKUM'S L2/3 NMDA PROJECT 


//====================== General files and tools =====================
load_file("nrngui.hoc")

//====================== cvode =======================================
objref cvode

cvode = new CVode()
cvode.active(1)

//=================== creating cell object ===========================
load_file("import3d.hoc")
objref L5PC

strdef morphology_file
morphology_file = "./Lucy23Cell1.asc"

load_file("./L5PCbiophys3.hoc")
load_file("./L5PCtemplate.hoc")
L5PC = new L5PCtemplate(morphology_file)


//================ ADAM PROCEDURES AND FUNCTIONS =======================
xopen("DefineSections.hoc")

xopen("ChangeBiophys.hoc")

xopen("AccessoryFunctions.hoc")

xopen("distSynsUniform.hoc")
xopen("distSynsCluster2.hoc")

/*
Compute_Sag()
Compute_Zin()
Compute_SagDend()
*/

objref synList1, synList2, synList_Background, synList4, synList_CSplus_tuft, synList_CSplus_basal, synList_CSminus_tuft, synList_CSminus_basal
synList1 = new List()
synList2 = new List()
synList_Background = new List()
synList4 = new List()
//synList = distSynsUniform(100, basalList,1,1)
nClustTuft = 15
nClustBasal = 10
nPerClust = 10 //MAKE THIS A MULTIPLE OF 4
//synList1 = distSynsCluster2(nClustTuft,tuftList,1,1,nPerClust,15)	 // clustered tuft input
//synList1 = distSynsUniform(nClustTuft*nPerClust,tuftList,1,1)
//synList2 = distSynsUniform(140,basalList,1,1) // background input
//distSynsCluster2(nClustBasal,basalList,1,1,nPerClust,15) // cluster basal input
//synList_Background = distSynsUniform(100,allSections,1,1) // background input

nBackgroundSyns = 100
nBasalSyns = 140 // number of basal synapses for CS+ and CS-
nCSplusTuftSyns = 120 // number of tuft synapses for CS+
nCSminusTuftSyns = 70 // number of tuft synapses for CS-

synList_CSplus_tuft = distSynsUniform(nCSplusTuftSyns,tuftList,1,1,123)
synList_CSplus_basal = distSynsUniform(nBasalSyns,basalList,1,1,1234)
synList_CSminus_tuft = distSynsUniform(nCSminusTuftSyns,tuftList,1,1,5463)
synList_CSminus_basal = distSynsUniform(nBasalSyns,basalList,1,1,32489)
synList_Background = distSynsUniform(100,allSections,1,1,12452) // background input

// numClust = $1 //number of clusters
	// section list for synapses to be distributed over= $2
	// gmax = $3, this is the max conductance of the nmda current
	// ntar = $4, this defines the conductance of the ampa current
	//            with ampa current = gmax/ntar
	// synsPerClust =$5 //number of synapses per cluster
	// lClust = $6 //length of cluster


// ============== Draw Synapses On Neuron Pic ============
// Draw points for CS+
for i=0,synList_CSplus_tuft.count()-1{
    shapeG.point_mark(synList_CSplus_tuft.object(i),2,"O",5)
}
for i=0,synList_CSplus_basal.count()-1{
    shapeG.point_mark(synList_CSplus_basal.object(i),2,"O",5)
}

// Draw points for CS-
for i=0,synList_CSminus_tuft.count()-1{
    shapeG.point_mark(synList_CSminus_tuft.object(i),5,"O",3)
}
for i=0,synList_CSminus_basal.count()-1{
    shapeG.point_mark(synList_CSminus_basal.object(i),5,"O",3)
}

// Draw points for background
for i=0,synList_Background.count()-1{
    shapeG.point_mark(synList_Background.object(i),4,"O",3)
}
//=================== SIMULATION ================================


print "\n\n\nSTART THE TUNING OF BACKGROUND SYNAPSES\n"
print "Stage 1: Find Resting State"


//===== Set all conductances to zero ===================

for i=0,synList_CSplus_tuft.count()-1{ synList_CSplus_tuft.object(i).gmax = 0.0 }
for i=0,synList_CSplus_basal.count()-1{ synList_CSplus_basal.object(i).gmax = 0.0 }

for i=0,synList_CSplus_tuft.count()-1{ synList_CSplus_tuft.object(i).gmax = 0.0 }
for i=0,synList_CSplus_basal.count()-1{ synList_CSplus_basal.object(i).gmax = 0.0 }

for i=0,synList_Background.count()-1{ synList_Background.object(i).gmax = 0.0 }



// ====== Find resting potential =====
access L5PC.soma
objref vrec
vrec = new Vector()
vrec.record(&L5PC.soma.v(0.5))
finitialize(-89.7)
forall{ v = -90 }
tstop = 20000
run()
vrest = vrec.x[vrec.size() - 1]
print "REST AFTER LONG CVODE RUN IS ", vrest, " AT TIME ", t
objref svstate
svstate  = new SaveState()
svstate.save()
cvode.active(0)
finitialize(-89.7)
svstate.restore()
tstop = t+20
dt = 0.025
//dt = 0.1
while(t<tstop){fadvance()}
vrest = vrec.x[vrec.size() - 1]
print "REST AFTER NONCVODE RUN IS ", vrest, " AT TIME ", t

simStopTime = t
svstate.save()

access L5PC.soma
distance(0)

// ============ SET UP BACKGROUND SYNAPSES ==============

objref vd
objref vg

vd = new Vector()
vg = new Vector()

objref vBrec,r3, trec
vBrec = new Vector()
print "Begin iterating through background synapses"

for i=0,synList_Background.count()-1{ 
	where = synList_Background.object(i).get_loc()
	distdist = distance(where)
	pop_section()
	synList_Background.object(i).gmax = 0.2683+0.0625*exp(distdist/158.0158)
	synList_Background.object(i).gmax = synList_Background.object(i).gmax
	r3 = new Random(i*7567)
	synList_Background.object(i).del = simStopTime+r3.uniform(-500,132)
	synList_Background.object(i).ntar = 1
	synList_Background.object(i).Tspike = r3.uniform(20,100) //50 Hz
	synList_Background.object(i).Nspike = 200
	

	print "Added a background synapse at distance ", distdist, " with timing of ", synList_Background.object(i).del-simStopTime
}
		vBrec = new Vector()
		trec = new Vector()
		svstate.restore(1)
		tstop = t+1250
		dt = 0.05
		//dt = 0.1
		while(t<tstop){
			fadvance()
			vBrec.append(L5PC.soma.v)
			trec.append(t)
			}


// =========== SET UP MANY FILES FOR OUTPUT ==================
objref ff1,ff2, fd1, fd2, fd3, fd4, fd5, fd6, fb1, fb2, fb3, fb4
objref vd1, vd2, vd3, vd4, vd5, vd6, vb1, vb2, vb3, vb4
ff1 = new File()
ff2 = new File()
ff1.wopen("rawVDistControl0.dat")	
ff2.wopen("subVDistControl0.dat")

fd1 = new File()
fd2 = new File()
fd3 = new File()
fd4 = new File()
fd5 = new File()
fd6 = new File()

fb1 = new File()
fb2 = new File()
fb3 = new File()
fb4 = new File()

ff1.wopen("rawVDistControl0.dat")	
ff2.wopen("subVDistControl0.dat")

fd1.wopen("dendV1.dat")	
fd2.wopen("dendV2.dat")	
fd3.wopen("dendV3.dat")	
fd4.wopen("dendV4.dat")	
fd5.wopen("dendV5.dat")	
fd6.wopen("dendV6.dat")	

fb1.wopen("basalV1.dat")	
fb2.wopen("basalV2.dat")	
fb3.wopen("basalV3.dat")	
fb4.wopen("basalV4.dat")

// ========= END SET UP FILES ==========


// ========== ACTUAL SIMULATION RUNS ===========
objref testing2
for repeat=0,10{
	print repeat
	// First choose a random set of background synapses
	
	testing2 = distSynsUniform(100,allSections,1,1,repeat*2340+1) // background input

	vrec = new Vector()
	trec = new Vector()
	svstate.restore(1)
	tstop = t+1250
	dt = 0.05

	while(t<tstop){
		fadvance()
		vrec.append(L5PC.soma.v)
		trec.append(t)
	}
		
	vrec.sub(vBrec)
	vrec.printf(ff2,"%8.4f\t")
	ff2.printf("\n")
	testVal = vrec.max()
	
	print "vmax is ", vrec.max()


} // END FOR REPEAT


// Constant basal input!
for k=0,synList2.count()-1{ 
	r_ = r3.uniform(0,500)
	synList2.object(k).gmax = 1.0
	synList2.object(k).del=(simStopTime+500) + r_ 
	synList2.object(k).Nspike = 1	
}


objref nClustSyns
nClustSyns = new Vector(nPerClust)
for j=0,synList1.count()-1{ synList1.object(j).gmax = 0.0 }
print "Begin iterating through clusters"







for i=0,nClustTuft-1{ 
	print i
	
	for k=0,nClustSyns.size()-1{ nClustSyns.x[k]=k+nPerClust*i }
	for k=0,nClustSyns.size()-1{ nClustSyns.x[k]=int(r3.uniform(0,synList1.count()-1)) }
	
	


	for k=0,nClustSyns.size()-1{ 
		
		synList1.object(nClustSyns.x[k]).gmax=r3.uniform(0.8,1.2)

		if (k>=nClustSyns.size()/10){ //PUT 25% of the synapses in the first 50 ms, the rest in the next 450
			r_ = r3.uniform(0,500)
			synList1.object(nClustSyns.x[k]).del=(simStopTime+500) + r_
			synList1.object(nClustSyns.x[k]).Nspike = 1		
		}
		
		if (k<nClustSyns.size()/10){ //PUT 25% of the synapses in the first 50 ms, the rest in the next 450
			r_ = r3.uniform(0,500)
			synList1.object(nClustSyns.x[k]).del=(simStopTime+500) + r_	
			synList1.object(nClustSyns.x[k]).Nspike = 1			
		}
		
		shapeG.point_mark(synList1.object(nClustSyns.x[k]),3,"O",8)
		
	
		pop_section()
	}



	
		if (i>5 || i==0){ // IF STATEMENT 1
		vrec = new Vector()
		trec = new Vector()

		vd1 = new Vector()
		vd2 = new Vector()
		vd3 = new Vector()
		vd4 = new Vector()
		vd5 = new Vector()
		vd6 = new Vector()

		vb1 = new Vector()
		vb2 = new Vector()
		vb3 = new Vector()
		vb4 = new Vector()


		//vrec.record(&L5PC.soma.v(0.5))
		svstate.restore(1)
		tstop = t+1250
		dt = 0.05
		//dt = 0.1
		while(t<tstop){
			fadvance()
			vrec.append(L5PC.soma.v)
			trec.append(t)
			vd1.append(L5PC.apic[22].v(0.5))
			vd2.append(L5PC.apic[33].v(0.8))
			vd3.append(L5PC.apic[38].v(0.8))
			vd4.append(L5PC.apic[51].v(0.8))
			vd5.append(L5PC.apic[26].v(0.96))
			vd6.append(L5PC.apic[56].v(0.75))

			vb1.append(L5PC.dend[38].v(0.45))
			vb2.append(L5PC.dend[45].v(0.54))
			vb3.append(L5PC.dend[65].v(0.64))
			vb4.append(L5PC.dend[7].v(0.62))
			}
		
		
		



	vrec.printf(ff1,"%8.4f\t")
	ff1.printf("\n")

	vd1.printf(fd1,"%8.4f\t")
	fd1.printf("\n")

	vd2.printf(fd2,"%8.4f\t")
	fd2.printf("\n")
	
	vd3.printf(fd3,"%8.4f\t")
	fd3.printf("\n")

	vd4.printf(fd4,"%8.4f\t")
	fd4.printf("\n")

	vd5.printf(fd5,"%8.4f\t")
	fd5.printf("\n")

	vd6.printf(fd6,"%8.4f\t")
	fd6.printf("\n")
		
	vb1.printf(fb1,"%8.4f\t")
	fb1.printf("\n")

	vb2.printf(fb2,"%8.4f\t")
	fb2.printf("\n")
	
	vb3.printf(fb3,"%8.4f\t")
	fb3.printf("\n")

	vb4.printf(fb4,"%8.4f\t")
	fb4.printf("\n")		
		
		
		
		vrec.sub(vBrec)
		vrec.printf(ff2,"%8.4f\t")
		ff2.printf("\n")
		testVal = vrec.max()






		
		print "vmax is ", vrec.max()
		} // IF STATEMENT 1
	
}

ff1.close()
ff2.close()

fd1.close()
fd2.close()
fd3.close()
fd4.close()
fd5.close()
fd6.close()

fb1.close()
fb2.close()
fb3.close()
fb4.close()


quit()



